###
# Functions for combining data only

library(tidyverse)

library(ggpubr)

outFolder <- "D:/SAM/Documents/V2_resistance/resistance/"
inFolder <- "D:/SAM/Documents/V2_resistance/resistance/Data/"
# Import files generated by SensiAnMosaic:

loadRData <- function(fileName){
  #loads an RData file, and returns it
  load(fileName)
  get(ls()[ls() != "fileName"])
}


get_RAF <- function(data,feed_stat,eff_stat){ 
  
  zMatrix <- matrix(NA, ncol=2, nrow=ncol(data$input))
  
  zMatrix[,1] <- c(1:nrow(zMatrix))
  
  colnames(zMatrix)<-c("Scenario","RAF>0.5_both")
  
  # Calculate RAF from the individual lists: 
  
  print("Check code if generations >500, this code has a [check] that involves 500/501")
  
  for( r in 1:nrow(zMatrix)){
    
    scenario = zMatrix[r,1]
    
    RAF_results <- data.frame(data$results[[scenario]] )
    
    
    # Now mutate this matrix to get i.e: freq_R1=(m.R1+f.R1)/2 for both locus 1 and locus 2 
    
    RAF_results <- mutate(RAF_results, RAF_freq_loc1 = (m.R1 + f.R1) / 2 ) %>%
      mutate(RAF_freq_loc2 = (m.R2 + f.R2) / 2 )
    
    
    # Now, for each scenario, need to find which gen >both< locus >0.5, noting that gen is rows of RAF_results_xxx 
    # NOTE: Dependent on calling index of results that are saved within the output of previous models
    
    RAF_gen <- which(RAF_results[ , 13] > 0.5 & RAF_results[ , 14] > 0.5)
    RAF_gen <- RAF_gen[1]
    
    
    zMatrix[r,2] <- RAF_gen
    
    # Calculate z ?
    # Replace NAs with 501.. this will also change z but we can re-calculate. Clunky, but works. 
    # Can't just exclude these as we need to index them later. 
    # NOTE: If gens ever > 500 this should be adjusted. 
    
    zMatrix[is.na(zMatrix)] <- 501
    
    
  }
  
  
  zMatrix <- data.frame(zMatrix)
  
  # This is just labeling.
  
  zMatrix$Feeds <- feed_stat
  zMatrix$Effectiveness <- eff_stat
  
  # Dummy column to be filled for cpd:
  
  # if include cpd = 1, include the correct deploy parameter in the z_matrix. 
  
  
  dat_input <- data$input
  cpd_vector<-c()
  
  for(i in 1:nrow(zMatrix)){
    
    cpd_param <- dat_input[55,i]
    #print(cpd_param)
    cpd_vector <- c(cpd_vector,cpd_param)
    
  }
  # Row 55, column is per loop.
  
  zMatrix$cpd <- cpd_vector
  return(zMatrix)
  
  
}

# Function to snip the 501s. Perhaps of limited use as we'd only censor in a comparison, but it's here.
censor_RAF <- function(RAF_data){
  
  censored_data <- dplyr::filter(RAF_data,RAF_data$RAF.0.5_both<501)  
  return(censored_data)
}

comparison_create <- function(data1,data2,feed_stat,eff_stat,maxGen){  
  
  print("Note that ratio is data 1 / data 2 - 1 *100, mixtures should be first to preserve consistency")
  zMatrix <- matrix(NA, ncol=4, nrow=ncol(data1$input))
  
  zMatrix[,1] <- c(1:nrow(zMatrix))
  
  colnames(zMatrix)<-c("Scenario","RAF>0.5_both_1", "RAF>0.5_both_2", "z")
  
  # Calculate RAF from the individual lists: 
  
  
  for( r in 1:nrow(zMatrix)){
    
    scenario = zMatrix[r,1]
    
    RAF_results_data1 <- data.frame(data1$results[[scenario]] )
    RAF_results_data2 <- data.frame(data2$results[[scenario]] )
    
    # Now mutate this matrix to get i.e: freq_R1=(m.R1+f.R1)/2 for both locus 1 and locus 2 
    # Do this twice, one for Mosaic, one for mixture. Then we can calculate z. 
    
    RAF_results_data1 <- mutate(RAF_results_data1, RAF_freq_loc1 = (m.R1 + f.R1) / 2 ) %>%
      mutate(RAF_freq_loc2 = (m.R2 + f.R2) / 2 )
    
    RAF_results_data2 <- mutate(RAF_results_data2, RAF_freq_loc1 = (m.R1 + f.R1) / 2 ) %>%
      mutate(RAF_freq_loc2 = (m.R2 + f.R2) / 2 )
    
    
    # Now, for each scenario, need to find which gen >both< locus >0.5, noting that gen is rows of RAF_results_xxx 
    # This strikes me as a shit way of doing it... but it works? 
    
    RAF_gen_data1 <- which(RAF_results_data1[ , 13] > 0.5 & RAF_results_data1[ , 14] > 0.5)
    RAF_gen_first_data1 <- RAF_gen_data1[1]
    
    RAF_gen_data2 <- which(RAF_results_data2[ , 13] > 0.5 & RAF_results_data2[ , 14] > 0.5)
    RAF_gen_first_data2 <- RAF_gen_data2[1]
    
    
    zMatrix[r,2] <- RAF_gen_first_data1
    zMatrix[r,3] <- RAF_gen_first_data2
    
    # Calculate z ?
    # Replace NAs with x+1.. this will also change z but we can re-calculate. Clunky, but works. 
    zMatrix[is.na(zMatrix)] <- maxGen + 1
    
    
    #Z =  ( L(m)/L(mm) - 1 ) *100
    zMatrix[r,4] <- (zMatrix[r,2] / zMatrix[r,3] - 1) * 100
    
  }
  
  zMatrix <- data.frame(zMatrix)
  
  zMatrix$Feeds <- feed_stat
  zMatrix$Effectiveness <- eff_stat
  
  return(zMatrix)
  
  
}


# Censor runs where both ==501. Function to do so:
censor_RAF_2 <- function(comparison_zMatrix,maxGen){
  
  RAFvec<-c()
  
  for(i in 1:nrow(comparison_zMatrix)){
    
    # Use pmax
    # If both ==501 then note 502. Else, take the higher (which might be 501). 
    ifelse(comparison_zMatrix[i,"RAF.0.5_both_1"] && comparison_zMatrix[i,"RAF.0.5_both_2"] == maxGen+1, 
           RAFnum <- maxGen+2, RAFnum <- max(dplyr::select(comparison_zMatrix,"RAF.0.5_both_1","RAF.0.5_both_2")[i,])
           
    )
    RAFvec<-c(RAFvec,RAFnum)
  } # end getting RAFvec
  
  # Now get the 502s for censor
  RAF_502<-c()
  for(c in 1:length(RAFvec)){
    if(RAFvec[c]==maxGen+2){
      RAF_502<-c(RAF_502,c)
    }
  }
  
  censored_zMatrix<-comparison_zMatrix[-c(RAF_502),]
  return(censored_zMatrix)
}


########
# Then data stewardship takes the following form:

#MIXPAN250gen <- censor_RAF_2(comparison_create(Mix_250gen,Pan_250gen,"Multiple","1",250),250)
#save(MIXPAN250gen,file= "D:/SAM/Documents/V2_Resistance/Resistance/Data/MIXPAN250gen.rda")


